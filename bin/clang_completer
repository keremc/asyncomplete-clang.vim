#!/usr/bin/env python2

from __future__ import print_function

import json
import logging
import os
import os.path

from clang.cindex import Config, Index, CompilationDatabase


def get_logger():
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)

    log_file = os.getenv('CLANG_COMPLETER_LOG_FILE')
    if log_file:
        handler = logging.FileHandler(log_file)
    else:
        handler = logging.NullHandler()

    handler.setLevel(logging.DEBUG)

    logger.addHandler(handler)

    return logger


logger = get_logger()

Config.set_compatibility_check(False)

idx = Index.create()
trans_units = {}
compilation_dbs = {}


def find_compilation_db(path):
    last_dir = path
    while True:
        parent_dir = os.path.abspath(os.path.join(last_dir, '..'))

        if parent_dir == last_dir:
            break
        last_dir = parent_dir

        if os.path.isfile(os.path.join(parent_dir, 'compile_commands.json')):
            return parent_dir


def get_compilation_db(path):
    compilation_db_dir = find_compilation_db(path)

    if compilation_db_dir is None:
        return

    if path in compilation_dbs:
        compilation_db = compilation_dbs[compilation_db_dir]
    else:
        compilation_db = CompilationDatabase.fromDirectory(compilation_db_dir)
        compilation_dbs[compilation_db_dir] = compilation_db
    return compilation_db


def collect_args(path):
    args = [
        '-I/usr/include/c++/7',
        '-I/usr/include/c++/7/x86_64-redhat-linux',
        '-I/usr/include/c++/7/backward',
        '-I/usr/local/include',
        '-I/usr/lib64/clang/4.0.1/include',
        '-I/usr/include'
    ]

    compilation_db = get_compilation_db(path)
    if compilation_db is not None:
        compile_cmds = compilation_db.getCompileCommands(path)
        if compile_cmds is not None:
            for arg in compile_cmds[0].arguments:
                if arg == path:
                    continue
                args.append(arg)

    return args


def get_trans_unit(path):
    if path in trans_units:
        trans_unit = trans_units[path]
    else:
        trans_unit = idx.parse(path, collect_args(path))
        trans_units[path] = trans_unit
    return trans_unit


def process_comp_str(string):
    word = ''
    menu = ''

    if string.availability.name in ['NotAvailable', 'NotAccessible']:
        return None
    elif len(string) == 1:
        word = string[0].spelling
    else:
        for chunk in string:
            if chunk.isKindResultType():
                menu += chunk.spelling
                menu += ' '
            elif chunk.isKindTypedText():
                word = chunk.spelling
                menu += chunk.spelling
            else:
                menu += chunk.spelling

    return {'word': word, 'menu': menu, 'dup': 1}


def get_comps(path, line, col, buf):
    comps = []

    trans_unit = get_trans_unit(path)
    results = trans_unit.codeComplete(path, line, col, [(path, buf)], True)

    for res in results.results:
        comp = process_comp_str(res.string)
        if comp is None or comp in comps:
            continue
        comps.append(comp)

    return comps


def process(req_type, req):
    if req_type == 'parse':
        trans_unit = get_trans_unit(str(req['path']))
        trans_unit.reparse()
    elif req_type == 'comp':
        return {'comps': get_comps(
            str(req['path']),
            req['line'],
            req['col'],
            str(req['buf'])
        )}


while True:
    line = raw_input()

    req = json.loads(line)
    req_id = req['id']
    req_type = req['type']

    logger.debug('REQ: %s', req)

    resp = process(req_type, req)

    logger.debug('RESP: %s', resp)

    if resp is None:
        continue

    resp['id'] = req_id
    resp['type'] = req_type
    print(json.dumps(resp))
