#!/usr/bin/env python2

from __future__ import print_function

import json

from clang.cindex import Config, Index

Config.set_compatibility_check(False)

idx = Index.create()
trans_units = {}


def collect_args(path):
    return [
        '-std=c++14',
        '-I/usr/include/c++/7',
        '-I/usr/include/c++/7/x86_64-redhat-linux',
        '-I/usr/include/c++/7/backward',
        '-I/usr/local/include',
        '-I/usr/lib64/clang/4.0.1/include',
        '-I/usr/include'
    ]


def parse(path, buf):
    if path in trans_units:
        tu = trans_units[path]
        tu.reparse([(path, buf)])
    else:
        tu = idx.parse(path, collect_args(path), [(path, buf)])
        trans_units[path] = tu


def process_comp_str(string):
    word = ''
    menu = ''

    if string.availability.name in ['NotAvailable', 'NotAccessible']:
        return None
    elif len(string) == 1:
        word = string[0].spelling
    else:
        for chunk in string:
            if chunk.isKindResultType():
                menu += chunk.spelling
                menu += ' '
            elif chunk.isKindTypedText():
                word = chunk.spelling
                menu += chunk.spelling
            else:
                menu += chunk.spelling

    return {'word': word, 'menu': menu, 'dup': 1}


def get_comps(path, line, col, buf):
    comps = []

    tu = trans_units[path]
    results = tu.codeComplete(path, line, col, [(path, buf)], True)

    for res in results.results:
        comp = process_comp_str(res.string)
        if comp is None or comp in comps:
            continue
        comps.append(comp)

    return comps


while True:
    line = raw_input()
    req = json.loads(line)

    path = str(req['path'])
    col = req['col']
    buf = str(req['buf'])

    parse(path, buf)
    comps = get_comps(path, req['line'], col, buf)

    print(json.dumps({'comps': comps, 'id': req['id'], 'col': col}))
